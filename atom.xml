<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>A Mjn Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/mjnhmd/"/>
  <updated>2016-03-23T12:55:07.208Z</updated>
  <id>https://github.com/mjnhmd/</id>
  
  <author>
    <name>MJN</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Handler实现原理</title>
    <link href="https://github.com/mjnhmd/2016/03/23/Handler%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>https://github.com/mjnhmd/2016/03/23/Handler实现原理/</id>
    <published>2016-03-23T12:52:31.000Z</published>
    <updated>2016-03-23T12:55:07.208Z</updated>
    
    <content type="html">&lt;p&gt;今天在尝试把百度定位sdk的初始化转移到子线程时，遇到了一个问题：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;java.lang.RuntimeException: Can&amp;apos;t create handler inside thread that has not called Looper.prepare()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个问题并不少见，网上一搜有很多。&lt;br&gt;解决方法就是在创建handler时传入Looper.getMainLooper()。&lt;/p&gt;
&lt;p&gt;但是我发现我在子线程执行的代码里并没有创建handler，只是创建了一个百度sdk的定位类。&lt;br&gt;显然是在这个类里边创建了handler，导致了这个问题。显然这个方法解决不了我的问题，由于handler并不是我创建的，我并没有办法给它传进去一个looper。&lt;/p&gt;
&lt;p&gt;只能看一下后台的实现原理，决定怎么解&lt;/p&gt;
&lt;p&gt;首先看下源码，在哪里报的错：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public Handler(Callback callback, boolean async) {
    if (FIND_POTENTIAL_LEAKS) {
        final Class&amp;lt;? extends Handler&amp;gt; klass = getClass();
        if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;amp;&amp;amp;
                (klass.getModifiers() &amp;amp; Modifier.STATIC) == 0) {
            Log.w(TAG, &amp;quot;The following Handler class should be static or leaks might occur: &amp;quot; +
                klass.getCanonicalName());
        }
    }

    mLooper = Looper.myLooper();
    if (mLooper == null) {
        throw new RuntimeException(
            &amp;quot;Can&amp;apos;t create handler inside thread that has not called Looper.prepare()&amp;quot;);
    }
    mQueue = mLooper.mQueue;
    mCallback = callback;
    mAsynchronous = async;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到是在handler的构造函数中抛出的异常,从代码和错误内容都不难看出是获取looper失败。那么我们再看一下这个Looper.myLooper()方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static Looper myLooper() {
    return sThreadLocal.get();
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;它只是返回了一个线程里的looper，显然是这个线程里没有looper造成的。线程里的looper是在哪里设置的呢?我们通过错误的内容“has not called Looper.prepare()”可以推断出应该就是prepare()方法了：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static void prepare() {
    prepare(true);
}

private static void prepare(boolean quitAllowed) {
    if (sThreadLocal.get() != null) {
        throw new RuntimeException(&amp;quot;Only one Looper may be created per thread&amp;quot;);
    }
    sThreadLocal.set(new Looper(quitAllowed));
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里可以看到一个线程里只能有一个looper。&lt;/p&gt;
&lt;p&gt;那么Looper到底是干嘛的呢？&lt;br&gt;首先我们都知道收到消息都是在handleMessage()方法处理的。我们就从最熟悉的地方找起，handleMessage方法是在哪调的呢：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void dispatchMessage(Message msg) {
    if (msg.callback != null) {
        handleCallback(msg);
    } else {
        if (mCallback != null) {
            if (mCallback.handleMessage(msg)) {
                return;
            }
        }
        handleMessage(msg);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到是在dispatchMessage(Message msg)里调用的。这里先判断有没有callback，也就是Runnable，如果自己写了runnable，那么就交由runnable处理&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private static void handleCallback(Message message) {
    message.callback.run();
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果没有，则调用handleMessage()方法。&lt;/p&gt;
&lt;p&gt;继续往上找， dispatchMessage(Message msg)是在这里调用的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static void loop() {
    final Looper me = myLooper();
    if (me == null) {
        throw new RuntimeException(&amp;quot;No Looper; Looper.prepare() wasn&amp;apos;t called on this thread.&amp;quot;);
    }
    final MessageQueue queue = me.mQueue;

    for (;;) {
        Message msg = queue.next(); // might block
        if (msg == null) {
            // No message indicates that the message queue is quitting.
            return;
        }
        msg.target.dispatchMessage(msg);
        msg.recycleUnchecked();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里有很多代码，我们只捡关心的看，首先他拿到了当前的looper，然后从中获取了一个队列，也就是消息队列。可以知道一个looper里会有一个消息队列。然后是一个死循环，循环获取队列中的message，然后调用之前的dispatchMessage(msg)。这样就把整个过程连起来了：&lt;/p&gt;
&lt;p&gt;Looper维持一个消息队列，然后不断的从队列里边拿出消息，然后交给handelr处理。还差一点，就是队列里的消息是从哪来的呢。这个相信用过的人都知道，自然就是sendMessage：&lt;br&gt;     public final boolean sendMessage(Message msg)&lt;br&gt;    {&lt;br&gt;        return sendMessageDelayed(msg, 0);&lt;br&gt;    }&lt;br&gt;可以看到这是一个包装，经过一系列的调用链，最终调用到了&lt;br&gt;    queue.enqueueMessage(msg, uptimeMillis)&lt;br&gt;这个queue就是从looper里获取到的那个消息队列，这个方法里就是一个典型的队列链表操作：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; boolean enqueueMessage(Message msg, long when) {
    synchronized (this) {
        msg.markInUse();
        msg.when = when;
        Message p = mMessages;
        boolean needWake;
        if (p == null || when == 0 || when &amp;lt; p.when) {
            // New head, wake up the event queue if blocked.
            msg.next = p;
            mMessages = msg;
            needWake = mBlocked;
        } else {
            needWake = mBlocked &amp;amp;&amp;amp; p.target == null &amp;amp;&amp;amp; msg.isAsynchronous();
            Message prev;
            for (;;) {
                prev = p;
                p = p.next;
                if (p == null || when &amp;lt; p.when) {
                    break;
                }
                if (needWake &amp;amp;&amp;amp; p.isAsynchronous()) {
                    needWake = false;
                }
            }
            msg.next = p; // invariant: p == prev.next
            prev.next = msg;
        }
    }
    return true;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;好了现在就全明白了，handler拿着一个looper，不断地往looper手里的消息队列里放消息，looper拿着这个消息队列又不断地往出取，让handler来处理消息。&lt;/p&gt;
&lt;p&gt;至于最开始的问题，已经很简单了。只需要在线程中调用Looper.prepare()在线程中放一个looper,然后在最后执行Looper.loop()，让它不断的往出取消息就可以了。即使不直接往handler里传入looper，handler也会在构建时自动从线程中拿到looper。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;今天在尝试把百度定位sdk的初始化转移到子线程时，遇到了一个问题：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;java.lang.RuntimeException: Can&amp;apos;t create handler inside thread that has not called 
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://github.com/mjnhmd/2016/03/16/hello-world/"/>
    <id>https://github.com/mjnhmd/2016/03/16/hello-world/</id>
    <published>2016-03-16T02:41:26.515Z</published>
    <updated>2016-03-16T07:06:57.632Z</updated>
    
    <content type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;Create-a-new-post&quot;&gt;&lt;a href=&quot;#Create-a-new-post&quot; class=&quot;headerlink&quot; title=&quot;Create a new post&quot;&gt;&lt;/a&gt;Create a new post&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo new &lt;span class=&quot;string&quot;&gt;&quot;My New Post&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/writing.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Writing&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Run-server&quot;&gt;&lt;a href=&quot;#Run-server&quot; class=&quot;headerlink&quot; title=&quot;Run server&quot;&gt;&lt;/a&gt;Run server&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo server&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/server.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Server&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Generate-static-files&quot;&gt;&lt;a href=&quot;#Generate-static-files&quot; class=&quot;headerlink&quot; title=&quot;Generate static files&quot;&gt;&lt;/a&gt;Generate static files&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo generate&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/generating.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Generating&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Deploy-to-remote-sites&quot;&gt;&lt;a href=&quot;#Deploy-to-remote-sites&quot; class=&quot;headerlink&quot; title=&quot;Deploy to remote sites&quot;&gt;&lt;/a&gt;Deploy to remote sites&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo deploy&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/deployment.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Deployment&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
    
  </entry>
  
</feed>
